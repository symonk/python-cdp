"""The module responsible for parsing chrome devtools protocol specification
files into python objects."""
import argparse
import logging
import pathlib
import typing
from utils import name_to_snake_case
from utils import parse_browser_specification
from utils import parse_javascript_specification

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


DO_NOT_MODIFY_MODULE_HEADER = '''""" *** AUTO GENERATED FILE ***
This file was automatically generated by python-cdp.  Do not modify this file
as it is overwritten when new versions of the devtools protocol are released.  Instead modify the
code generator in https://github.com/symonk/python-cdp (or your fork) instead.  For documentation
on how to modify the generation process refer to the CONTRIBUTING.md file in the root of the
repository."""'''


def generate() -> int:
    """The main entry point for python generation."""
    browser_spec = parse_browser_specification()
    _ = parse_javascript_specification()
    for domain in browser_spec["domains"]:
        create_module(domain["domain"])
        dynamically_create_source(domain)
        # for now, only implementing the first domain as a proof of concept.
    return 0


def dynamically_create_source(domain: typing.Dict[str, typing.Any]) -> None:
    """Dynamically creates the content for the CDP domain in its respective
    module.

    :param object: The dictionary for the domain.
    """
    name = domain.get("domain")
    experimental = domain.get("experimental", False)
    commands = domain.get("commands", {})
    types = domain.get("types", {})
    events = domain.get("events", {})
    logger.info(
        f"Attempting to build contents for Domain({name}) -> Commands[{len(commands)}]|Types[{len(types)}]|Events[{len(events)}] [experimental: {experimental}]",  # noqa
    )
    # Handling types first makes sense?


def create_module(name: str) -> None:
    """Creates a new python module on disk (or overwrites an existing) module
    that contains that name."""
    name = name_to_snake_case(name if name.endswith(".py") else f"{name}.py")
    mod_path = str(pathlib.Path(__file__).parent / "cdp" / name)
    with open(mod_path, mode="w") as f:
        f.write(DO_NOT_MODIFY_MODULE_HEADER)


def handle_commandline_args() -> argparse.Namespace:
    """Handle command line arguments."""
    return argparse.ArgumentParser().parse_args()


if __name__ == "__main__":
    raise SystemExit(generate())
