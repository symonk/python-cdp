"""The module responsible for parsing chrome devtools protocol specification
files into python objects."""
import argparse
import logging
import pathlib
import typing

from python_cdp._utils import name_to_snake_case
from python_cdp._utils import parse_browser_specification
from python_cdp._utils import parse_javascript_specification

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


DO_NOT_MODIFY_MODULE_HEADER = '''""" *** AUTO GENERATED FILE ***
This file was automatically generated by python-cdp.  Do not modify this file
as it is overwritten when new versions of the devtools protocol are released.  Instead modify the
code generator in https://github.com/symonk/python-cdp (or your fork) instead.  For documentation
on how to modify the generation process refer to the CONTRIBUTING.md file in the root of the
repository."""'''


SIMPLE_DATACLASS = '''
@dataclass
class {clazz}:
    """ {docstring} """
'''

BASIC_IMPORTS = """
from __future__ import annotations
from dataclasses import dataclass
"""


def generate() -> int:
    """The main entry point for python generation."""
    browser_spec = parse_browser_specification()
    _ = parse_javascript_specification()
    for domain in browser_spec["domains"]:
        dynamically_create_source(domain)
        # for now, only implementing the first domain as a proof of concept.
    return 0


def dynamically_create_source(domain: typing.Dict[str, typing.Any]) -> None:
    """Dynamically creates the content for the CDP domain in its respective
    module.

    :param object: The dictionary for the domain.
    """
    name = typing.cast(str, domain.get("domain"))
    module = create_module(name)
    experimental = domain.get("experimental", False)
    commands = domain.get("commands", {})
    types = domain.get("types", {})
    events = domain.get("events", {})
    logger.info(
        f"Attempting to build contents for Domain({name}) -> Commands[{len(commands)}]|Types[{len(types)}]|Events[{len(events)}] [experimental: {experimental}]",  # noqa
    )
    # Handling types first makes sense?
    # is AST a viable approach? could get quite complicated, but so can templating anyway etc.

    with open(module, mode="a") as f:
        for type in types:
            the_type = type["type"]
            if the_type == "object":
                f.write(
                    SIMPLE_DATACLASS.format(
                        clazz=type["id"],
                        docstring=type.get("description", "Missing description in devtools protocol."),
                    ),
                )
            elif the_type == "string":
                ...


def create_module(name: str) -> str:
    """Creates a new python module on disk (or overwrites an existing) module
    that contains that name."""
    name = name_to_snake_case(name if name.endswith(".py") else f"{name}.py")
    mod_path = str(pathlib.Path(__file__).parent / "cdp" / name)
    with open(mod_path, mode="w") as f:
        f.write(DO_NOT_MODIFY_MODULE_HEADER)
        f.write(BASIC_IMPORTS)
    return mod_path


def handle_commandline_args() -> argparse.Namespace:
    """Handle command line arguments."""
    return argparse.ArgumentParser().parse_args()


if __name__ == "__main__":
    raise SystemExit(generate())
